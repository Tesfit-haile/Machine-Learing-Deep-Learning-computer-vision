import cv2import matplotlib.pyplot as plt""" Thresholding is separating or segmenting an object from it's background"""""" However it is better to use in some case adaptive threshold.... cuz this simple_threshold wont work"""img = cv2.imread('Photos/gradient_img.jpeg')cv2.imshow('img', img)_, threshed_img_1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)  # > 127 to 0 else to 255_, threshed_img_2 = cv2.threshold(img, 50, 255, cv2.THRESH_BINARY)  # depend on the value_, threshed_img_3 = cv2.threshold(img, 200, 255, cv2.THRESH_BINARY_INV)_, threshed_img_4 = cv2.threshold(img, 127, 255, cv2.THRESH_TRUNC)_, threshed_img_5 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO)""" instead of using 5 windows to show those images user plt with in for loop.... """# cv2.imshow('threshed_img_1', threshed_img_1)# cv2.imshow('threshed_img_2', threshed_img_2)# cv2.imshow('threshed_img_3', threshed_img_3)# cv2.imshow('threshed_img_4', threshed_img_4)# cv2.imshow('threshed_img_5', threshed_img_5)"""    SHOWING MULTIPLE IMAGES ON ONE WIDOW AT THE SAME TIME   """names = ['Original_img', 'BINARY', 'BINARY_INV', 'TRUNC', 'TOZERO', 'TOZERO_INV']images = [img, threshed_img_1, threshed_img_2, threshed_img_3, threshed_img_4, threshed_img_5]for i in range(len(names)):    plt.subplot(2, 3, i+1), plt.imshow(images[i], 'gray')  # 2, 3 --> col and row    plt.title(names[i])    plt.xticks([]), plt.yticks([])plt.show()cv2.waitKey(0)cv2.destroyAllWindows()